# Bot Commands & Architecture

## In-Game Commands (Optional)

Your bot.js can optionally parse commands from chat. Example patterns:

```javascript
// Detect commands: "botname command args"
const cmdMatch = message.toLowerCase().match(/^botname\s+(\w+)\s*(.*)?$/i);
if (cmdMatch) {
  const cmd = cmdMatch[1];
  const args = cmdMatch[2] || '';
  
  switch(cmd) {
    case 'follow':
      // Move towards player
      bot.pathfinder.setGoal(new GoalFollow(player));
      break;
    case 'stop':
      // Stop moving
      bot.pathfinder.setGoal(null);
      break;
    case 'status':
      // Report health, food, position
      bot.chat(`HP: ${bot.health}, Food: ${bot.food}, Pos: ${bot.entity.position}`);
      break;
    case 'help':
      bot.chat('Commands: follow, stop, status');
      break;
    // Add your custom commands here
  }
}
```

**Note:** The LLM monitor responds to ALL mentions with conversational LLM responses. Commands are optional and handled by your bot.js, not the monitor.

## Chat Log Format

The monitor expects chat logs in this exact format:

```
username: message text
another_player: hello there
```

**Example from bot.js:**
```javascript
bot.on('chat', (username, message) => {
  console.log(`${username}: ${message}`);  // Stdout â†’ redirected to log file
});
```

**File redirection (when starting bot):**
```bash
node bot.js > bot.log 2>&1 &
```

## Response File Schema

Your bot reads and processes this file every 1-2 seconds:

```json
[
  {
    "conversationId": 1,
    "text": "Response text the monitor generated"
  }
]
```

**Required format:**
- Array of objects
- Each object has `conversationId` and `text` fields
- `text` is sent directly to `bot.chat()`
- File is cleared after processing

## Optional: Persistent Memory

If your bot needs to remember locations or state:

```javascript
const memory = {
  visited: [],
  resources: {},
  players: {}
};

setInterval(() => {
  fs.writeFileSync('./memory.json', JSON.stringify(memory));
}, 60000);
```

## Optional: Bot-to-Bot Communication

Bots can detect and interact with each other via chat:

```javascript
bot.on('chat', (username, message) => {
  // Detect if speaker is another bot (by username pattern)
  if (username.includes('bot') || username.includes('Bot')) {
    // Inter-bot communication logic
  }
});
```

## Architecture Notes

- **Not a plugin:** This is a standalone mineflayer bot controlled by OpenClaw subagents
- **Real-time:** Monitor checks every 2 seconds, responses sent immediately
- **Stateless responses:** Response file is cleared after each read
- **Flexible personality:** Monitor generates responses matching any personality you specify

## Example Bot Skeleton

```javascript
const mineflayer = require('mineflayer');
const fs = require('fs');

const bot = mineflayer.createBot({
  host: 'localhost',
  port: 25565,
  username: 'MyBot',
  offline: true
});

// Log chat for monitor
bot.on('chat', (username, message) => {
  console.log(`${username}: ${message}`);
});

// Process responses from monitor
setInterval(() => {
  try {
    const responses = JSON.parse(fs.readFileSync('./responses.json'));
    responses.forEach(r => {
      if (r.text) bot.chat(r.text);
    });
    fs.writeFileSync('./responses.json', '[]');
  } catch(e) {}
}, 1000);

bot.on('spawn', () => {
  console.log('Bot spawned!');
});
```

## Monitor Script (Bash Example)

See `scripts/bot-monitor.sh` for a reference implementation:

```bash
# Usage:
./bot-monitor.sh MyBot ./bot.log ./responses.json "@all"

# Arguments:
# - MyBot: Your bot's Minecraft username
# - ./bot.log: Path to chat log file
# - ./responses.json: Path to responses.json
# - @all: Listen for all mentions (or specify player name)
```

This script:
- Reads bot.log continuously
- Detects messages containing bot name
- Tracks processed messages to prevent duplicates
- Logs new messages for processing

In production, responses are generated by OpenClaw subagents (via Claude), not by the monitoring script.
