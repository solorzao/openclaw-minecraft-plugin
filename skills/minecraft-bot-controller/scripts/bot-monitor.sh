#!/bin/bash
# Generic Minecraft Bot Monitor - Continuously reads bot log and generates responses
# 
# Usage: 
#   ./bot-monitor.sh BOT_NAME LOG_FILE RESPONSE_FILE [PLAYER_FILTER]
#
# Example:
#   ./bot-monitor.sh MyBot ./bot.log ./responses.json "Wookiee_23"
#   ./bot-monitor.sh MyBot ./bot.log ./responses.json "@all"
#
# Arguments:
#   BOT_NAME       - Bot's Minecraft username (e.g., MyBot, Nova_AI)
#   LOG_FILE       - Path to bot's chat log (e.g., ./bot.log)
#   RESPONSE_FILE  - Path to responses.json (e.g., ./responses.json)
#   PLAYER_FILTER  - (Optional) Player to listen for. Default: detect all mentions of BOT_NAME

set -e

# Parse arguments
BOT_NAME="${1:?Bot name required. Usage: $0 BOT_NAME LOG_FILE RESPONSE_FILE [PLAYER_FILTER]}"
LOG_FILE="${2:?Log file path required.}"
RESPONSE_FILE="${3:?Response file path required.}"
PLAYER_FILTER="${4:-@all}"

# State file for deduplication
STATE_DIR=$(dirname "$RESPONSE_FILE")
PROCESSED_MESSAGES_FILE="$STATE_DIR/.${BOT_NAME}-monitor-state"

# Validate files exist
if [ ! -f "$LOG_FILE" ]; then
    echo "‚ùå Error: Log file not found: $LOG_FILE"
    exit 1
fi

if [ ! -f "$RESPONSE_FILE" ]; then
    echo "‚ö†Ô∏è  Response file doesn't exist, creating: $RESPONSE_FILE"
    echo "[]" > "$RESPONSE_FILE"
fi

# Initialize processed messages tracking
touch "$PROCESSED_MESSAGES_FILE"

echo "ü§ñ Minecraft Bot Monitor Starting..."
echo "Bot Name:       $BOT_NAME"
echo "Log File:       $LOG_FILE"
echo "Response File:  $RESPONSE_FILE"
echo "Player Filter:  $PLAYER_FILTER"
echo ""
echo "Monitor will detect mentions and respond. Press Ctrl+C to stop."
echo ""

# Build grep pattern
if [ "$PLAYER_FILTER" == "@all" ]; then
    # Monitor all mentions of the bot
    PATTERN="$BOT_NAME"
else
    # Monitor specific player mentions
    PATTERN="$PLAYER_FILTER.*$BOT_NAME"
fi

# Main monitoring loop
while true; do
    # Get last 100 lines and look for relevant chat
    # Grep for: username: message (and filter for our pattern)
    NEW_LINES=$(tail -n 100 "$LOG_FILE" 2>/dev/null | grep -iE "^[a-zA-Z0-9_]+:\s" | grep -iE "$PATTERN" || true)
    
    if [ -n "$NEW_LINES" ]; then
        # Process each new chat line
        while IFS= read -r line; do
            # Create message hash for deduplication
            MSG_HASH=$(echo "$line" | md5sum | awk '{print $1}')
            
            # Check if we've already processed this message
            if ! grep -q "^$MSG_HASH$" "$PROCESSED_MESSAGES_FILE"; then
                # Mark as processed
                echo "$MSG_HASH" >> "$PROCESSED_MESSAGES_FILE"
                
                # Extract username and message
                USERNAME=$(echo "$line" | cut -d':' -f1)
                MSG_TEXT=$(echo "$line" | cut -d':' -f2- | sed 's/^\s*//')
                
                echo "üìù [$USERNAME] $MSG_TEXT"
                
                # NOTE: This script only detects messages. 
                # The actual response generation happens in OpenClaw via sessions_spawn.
                # This script serves as an example of how to detect new chat.
                # 
                # In production, responses are generated by Claude subagents
                # and written to $RESPONSE_FILE by the subagent task.
                
                echo "‚úÖ Message logged for processing"
            fi
        done <<< "$NEW_LINES"
    fi
    
    # Clean up old processed messages (keep only last 5000)
    LINES=$(wc -l < "$PROCESSED_MESSAGES_FILE" 2>/dev/null || echo 0)
    if [ "$LINES" -gt 5000 ]; then
        tail -n 5000 "$PROCESSED_MESSAGES_FILE" > "$PROCESSED_MESSAGES_FILE.tmp"
        mv "$PROCESSED_MESSAGES_FILE.tmp" "$PROCESSED_MESSAGES_FILE"
    fi
    
    sleep 2
done
